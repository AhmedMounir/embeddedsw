<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>lwip211: tcpip.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">lwip211
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tcpip_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tcpip.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>Sequential API Main thread module. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a93043b3c66dbe4a15a60299c6199d102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a93043b3c66dbe4a15a60299c6199d102">tcpip_inpkt</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, struct <a class="el" href="structnetif.html">netif</a> *inp, <a class="el" href="netif_8h.html#a5c22e25822921b5ac3b4cef67f2eaf3d">netif_input_fn</a> input_fn)</td></tr>
<tr class="memdesc:a93043b3c66dbe4a15a60299c6199d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a received packet to tcpip_thread for input processing.  <a href="#a93043b3c66dbe4a15a60299c6199d102">More...</a><br/></td></tr>
<tr class="separator:a93043b3c66dbe4a15a60299c6199d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae510f195171bed8499ae94e264a92717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#ae510f195171bed8499ae94e264a92717">tcpip_input</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, struct <a class="el" href="structnetif.html">netif</a> *inp)</td></tr>
<tr class="memdesc:ae510f195171bed8499ae94e264a92717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a received packet to tcpip_thread for input processing with ethernet_input or ip_input.  <a href="#ae510f195171bed8499ae94e264a92717">More...</a><br/></td></tr>
<tr class="separator:ae510f195171bed8499ae94e264a92717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab838fe3417ab3a1f61f0728009a0c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#aab838fe3417ab3a1f61f0728009a0c2a">tcpip_callback</a> (<a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a> function, void *ctx)</td></tr>
<tr class="memdesc:aab838fe3417ab3a1f61f0728009a0c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a specific function in the thread context of tcpip_thread for easy access synchronization.  <a href="#aab838fe3417ab3a1f61f0728009a0c2a">More...</a><br/></td></tr>
<tr class="separator:aab838fe3417ab3a1f61f0728009a0c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7b3c7414c76ad8dde14d2fba6cb020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#aeb7b3c7414c76ad8dde14d2fba6cb020">tcpip_try_callback</a> (<a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a> function, void *ctx)</td></tr>
<tr class="memdesc:aeb7b3c7414c76ad8dde14d2fba6cb020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a specific function in the thread context of tcpip_thread for easy access synchronization.  <a href="#aeb7b3c7414c76ad8dde14d2fba6cb020">More...</a><br/></td></tr>
<tr class="separator:aeb7b3c7414c76ad8dde14d2fba6cb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bdf37eddcd72c4178e3ea7d370395d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a12bdf37eddcd72c4178e3ea7d370395d">tcpip_send_msg_wait_sem</a> (<a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a> fn, void *apimsg, sys_sem_t *sem)</td></tr>
<tr class="memdesc:a12bdf37eddcd72c4178e3ea7d370395d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to TCPIP thread to call a function.  <a href="#a12bdf37eddcd72c4178e3ea7d370395d">More...</a><br/></td></tr>
<tr class="separator:a12bdf37eddcd72c4178e3ea7d370395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d42b0c46607f91aedcc7745ed466b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a3d42b0c46607f91aedcc7745ed466b08">tcpip_api_call</a> (tcpip_api_call_fn fn, struct tcpip_api_call_data *call)</td></tr>
<tr class="memdesc:a3d42b0c46607f91aedcc7745ed466b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously calls function in TCPIP thread and waits for its completion.  <a href="#a3d42b0c46607f91aedcc7745ed466b08">More...</a><br/></td></tr>
<tr class="separator:a3d42b0c46607f91aedcc7745ed466b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14fa2587a9ba9d23e4c7e16c4526ac"><td class="memItemLeft" align="right" valign="top">struct tcpip_callback_msg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#aee14fa2587a9ba9d23e4c7e16c4526ac">tcpip_callbackmsg_new</a> (<a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a> function, void *ctx)</td></tr>
<tr class="memdesc:aee14fa2587a9ba9d23e4c7e16c4526ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a structure for a static callback message and initialize it.  <a href="#aee14fa2587a9ba9d23e4c7e16c4526ac">More...</a><br/></td></tr>
<tr class="separator:aee14fa2587a9ba9d23e4c7e16c4526ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7a59f4c3f5f721ab9ee81f231c9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#ac5b7a59f4c3f5f721ab9ee81f231c9fd">tcpip_callbackmsg_delete</a> (struct tcpip_callback_msg *msg)</td></tr>
<tr class="memdesc:ac5b7a59f4c3f5f721ab9ee81f231c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a callback message allocated by <a class="el" href="tcpip_8c.html#aee14fa2587a9ba9d23e4c7e16c4526ac" title="Allocate a structure for a static callback message and initialize it. ">tcpip_callbackmsg_new()</a>.  <a href="#ac5b7a59f4c3f5f721ab9ee81f231c9fd">More...</a><br/></td></tr>
<tr class="separator:ac5b7a59f4c3f5f721ab9ee81f231c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe5fb2ea33e8c262567ac46f4db3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a83fe5fb2ea33e8c262567ac46f4db3f8">tcpip_callbackmsg_trycallback</a> (struct tcpip_callback_msg *msg)</td></tr>
<tr class="memdesc:a83fe5fb2ea33e8c262567ac46f4db3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to post a callback-message to the tcpip_thread tcpip_mbox.  <a href="#a83fe5fb2ea33e8c262567ac46f4db3f8">More...</a><br/></td></tr>
<tr class="separator:a83fe5fb2ea33e8c262567ac46f4db3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3a88b8df6ba3b9ed1c00e0a305e3db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a1f3a88b8df6ba3b9ed1c00e0a305e3db">tcpip_init</a> (<a class="el" href="tcpip_8h.html#a6fd556a6cb4c895d2361e44c96c8efba">tcpip_init_done_fn</a> initfunc, void *arg)</td></tr>
<tr class="memdesc:a1f3a88b8df6ba3b9ed1c00e0a305e3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize this module:  <a href="#a1f3a88b8df6ba3b9ed1c00e0a305e3db">More...</a><br/></td></tr>
<tr class="separator:a1f3a88b8df6ba3b9ed1c00e0a305e3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdcb6b784fe0e8736a5b31a5cfbed6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a5cdcb6b784fe0e8736a5b31a5cfbed6c">pbuf_free_callback</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="memdesc:a5cdcb6b784fe0e8736a5b31a5cfbed6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper function that allows you to free a pbuf from interrupt context.  <a href="#a5cdcb6b784fe0e8736a5b31a5cfbed6c">More...</a><br/></td></tr>
<tr class="separator:a5cdcb6b784fe0e8736a5b31a5cfbed6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4de3765c6a37b3f2b26a11603771c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcpip_8c.html#a55b4de3765c6a37b3f2b26a11603771c">mem_free_callback</a> (void *m)</td></tr>
<tr class="memdesc:a55b4de3765c6a37b3f2b26a11603771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper function that allows you to free heap memory from interrupt context.  <a href="#a55b4de3765c6a37b3f2b26a11603771c">More...</a><br/></td></tr>
<tr class="separator:a55b4de3765c6a37b3f2b26a11603771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a55b4de3765c6a37b3f2b26a11603771c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> mem_free_callback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple wrapper function that allows you to free heap memory from interrupt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the heap memory to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if callback could be enqueued, an err_t if not </dd></dl>

<p>References <a class="el" href="mem_8c.html#a65169147c44e9db60d997819af9b455c">mem_free()</a>, and <a class="el" href="tcpip_8c.html#aeb7b3c7414c76ad8dde14d2fba6cb020">tcpip_try_callback()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cdcb6b784fe0e8736a5b31a5cfbed6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> pbuf_free_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple wrapper function that allows you to free a pbuf from interrupt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pbuf (chain) to be dereferenced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if callback could be enqueued, an err_t if not </dd></dl>

<p>References <a class="el" href="tcpip_8c.html#aeb7b3c7414c76ad8dde14d2fba6cb020">tcpip_try_callback()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d42b0c46607f91aedcc7745ed466b08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_api_call </td>
          <td>(</td>
          <td class="paramtype">tcpip_api_call_fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tcpip_api_call_data *&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously calls function in TCPIP thread and waits for its completion. </p>
<p>It is recommended to use LWIP_TCPIP_CORE_LOCKING (preferred) or LWIP_NETCONN_SEM_PER_THREAD. If not, a semaphore is created and destroyed on every call which is usually an expensive/slow operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Function to call </td></tr>
    <tr><td class="paramname">call</td><td>Call parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value from tcpip_api_call_fn </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="group__sys__sem.html#ga8d364c5037778acb21c3df675db81b4f">sys_arch_sem_wait()</a>, <a class="el" href="group__sys__mbox.html#ga9d068386a3c53dd01b8af99c3ef77555">sys_mbox_post()</a>, <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>, <a class="el" href="group__sys__sem.html#ga83b781f96c30e915c752065a757da283">sys_sem_free()</a>, and <a class="el" href="group__sys__sem.html#gaf99da9e34a71855285c535183133dfde">sys_sem_new()</a>.</p>

</div>
</div>
<a class="anchor" id="aab838fe3417ab3a1f61f0728009a0c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a specific function in the thread context of tcpip_thread for easy access synchronization. </p>
<p>A function called in that way may access lwIP core code without fearing concurrent access. Blocks until the request is posted. Must not be called from interrupt context!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the function to call </td></tr>
    <tr><td class="paramname">ctx</td><td>parameter passed to f </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if the function was called, another err_t if not</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="tcpip_8h.html#aeb7b3c7414c76ad8dde14d2fba6cb020" title="Call a specific function in the thread context of tcpip_thread for easy access synchronization. ">tcpip_try_callback</a> </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaaaeafdbf3aecc46864daa3cd829c7e05">ERR_MEM</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="group__sys__mbox.html#ga9d068386a3c53dd01b8af99c3ef77555">sys_mbox_post()</a>, and <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b7a59f4c3f5f721ab9ee81f231c9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_callbackmsg_delete </td>
          <td>(</td>
          <td class="paramtype">struct tcpip_callback_msg *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a callback message allocated by <a class="el" href="tcpip_8c.html#aee14fa2587a9ba9d23e4c7e16c4526ac" title="Allocate a structure for a static callback message and initialize it. ">tcpip_callbackmsg_new()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="tcpip_8c.html#aee14fa2587a9ba9d23e4c7e16c4526ac" title="Allocate a structure for a static callback message and initialize it. ">tcpip_callbackmsg_new()</a> </dd></dl>

<p>References <a class="el" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free()</a>.</p>

</div>
</div>
<a class="anchor" id="aee14fa2587a9ba9d23e4c7e16c4526ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct tcpip_callback_msg* tcpip_callbackmsg_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a structure for a static callback message and initialize it. </p>
<p>The message has a special type such that lwIP never frees it. This is intended to be used to send "static" messages from interrupt context, e.g. the message is allocated once and posted several times from an IRQ using <a class="el" href="tcpip_8c.html#a83fe5fb2ea33e8c262567ac46f4db3f8" title="Try to post a callback-message to the tcpip_thread tcpip_mbox. ">tcpip_callbackmsg_trycallback()</a>. Example usage: Trigger execution of an ethernet IRQ DPC routine in lwIP thread context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the function to call </td></tr>
    <tr><td class="paramname">ctx</td><td>parameter passed to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a struct pointer to pass to <a class="el" href="tcpip_8c.html#a83fe5fb2ea33e8c262567ac46f4db3f8" title="Try to post a callback-message to the tcpip_thread tcpip_mbox. ">tcpip_callbackmsg_trycallback()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="tcpip_8c.html#a83fe5fb2ea33e8c262567ac46f4db3f8" title="Try to post a callback-message to the tcpip_thread tcpip_mbox. ">tcpip_callbackmsg_trycallback()</a> </dd>
<dd>
<a class="el" href="tcpip_8c.html#ac5b7a59f4c3f5f721ab9ee81f231c9fd" title="Free a callback message allocated by tcpip_callbackmsg_new(). ">tcpip_callbackmsg_delete()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a83fe5fb2ea33e8c262567ac46f4db3f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_callbackmsg_trycallback </td>
          <td>(</td>
          <td class="paramtype">struct tcpip_callback_msg *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to post a callback-message to the tcpip_thread tcpip_mbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to the message to post </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__sys__mbox.html#gaa36345e48a49d67cbb0878cd4cbd2195" title="Try to post a message to an mbox - may fail if full. ">sys_mbox_trypost()</a> return code</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="tcpip_8c.html#aee14fa2587a9ba9d23e4c7e16c4526ac" title="Allocate a structure for a static callback message and initialize it. ">tcpip_callbackmsg_new()</a> </dd></dl>

<p>References <a class="el" href="group__sys__mbox.html#gaa36345e48a49d67cbb0878cd4cbd2195">sys_mbox_trypost()</a>, and <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>.</p>

</div>
</div>
<a class="anchor" id="a1f3a88b8df6ba3b9ed1c00e0a305e3db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tcpip_8h.html#a6fd556a6cb4c895d2361e44c96c8efba">tcpip_init_done_fn</a>&#160;</td>
          <td class="paramname"><em>initfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize this module: </p>
<ul>
<li>initialize all sub modules</li>
<li>start the tcpip_thread</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initfunc</td><td>a function to call when tcpip_thread is running and finished initializing </td></tr>
    <tr><td class="paramname">arg</td><td>argument to pass to initfunc </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="init_8c.html#a0c1a18439524d2f4a5e51d25c0ca2ce9">lwip_init()</a>, <a class="el" href="group__sys__mbox.html#gab9793f30642de06ce87827e9adbe30cc">sys_mbox_new()</a>, <a class="el" href="group__sys__mutex.html#ga38e7dae1fd88b338eb1cd97f110f3897">sys_mutex_new()</a>, <a class="el" href="group__sys__misc.html#ga0d596afdd8dbcfad320172d39b0f607a">sys_thread_new()</a>, <a class="el" href="group__lwip__opts__thread.html#ga8cf210ad4e4bf616860a45fbd140fd06">TCPIP_MBOX_SIZE</a>, <a class="el" href="group__lwip__opts__thread.html#ga405e604e4328e1feb878c6fe1798a587">TCPIP_THREAD_NAME</a>, <a class="el" href="group__lwip__opts__thread.html#ga42b2c7a3042d7c3efd00f367f5837435">TCPIP_THREAD_PRIO</a>, and <a class="el" href="group__lwip__opts__thread.html#gaa02b84eafa0c8b09b158b97c96d79db0">TCPIP_THREAD_STACKSIZE</a>.</p>

</div>
</div>
<a class="anchor" id="a93043b3c66dbe4a15a60299c6199d102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_inpkt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="netif_8h.html#a5c22e25822921b5ac3b4cef67f2eaf3d">netif_input_fn</a>&#160;</td>
          <td class="paramname"><em>input_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass a received packet to tcpip_thread for input processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the received packet </td></tr>
    <tr><td class="paramname">inp</td><td>the network interface on which the packet was received </td></tr>
    <tr><td class="paramname">input_fn</td><td>input function to call </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaaaeafdbf3aecc46864daa3cd829c7e05">ERR_MEM</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free()</a>, <a class="el" href="group__sys__mbox.html#gaa36345e48a49d67cbb0878cd4cbd2195">sys_mbox_trypost()</a>, <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>, and <a class="el" href="group__lwip__opts__debugmsg.html#ga52d6c83451936c3de3b0338d4a3f921f">TCPIP_DEBUG</a>.</p>

<p>Referenced by <a class="el" href="tcpip_8h.html#ae510f195171bed8499ae94e264a92717">tcpip_input()</a>.</p>

</div>
</div>
<a class="anchor" id="ae510f195171bed8499ae94e264a92717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_input </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>inp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass a received packet to tcpip_thread for input processing with ethernet_input or ip_input. </p>
<p>Don't call directly, pass to <a class="el" href="group__netif.html#ga66970b5877dd6b0cae906bfa78d0cb4c" title="Add a network interface to the list of lwIP netifs. ">netif_add()</a> and call netif-&gt;input().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the received packet, p-&gt;payload pointing to the Ethernet header or to an IP header (if inp doesn't have NETIF_FLAG_ETHARP or NETIF_FLAG_ETHERNET flags) </td></tr>
    <tr><td class="paramname">inp</td><td>the network interface on which the packet was received </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structnetif.html#a1c171db6097bbb6f09f63549a66e00ea">netif::flags</a>, <a class="el" href="group__netif__flags.html#ga92448dc510bc8d700c09e5c971ef0676">NETIF_FLAG_ETHARP</a>, <a class="el" href="group__netif__flags.html#ga76ad9d0cf9f029df0ab2a998c64040dc">NETIF_FLAG_ETHERNET</a>, and <a class="el" href="tcpip_8c.html#a93043b3c66dbe4a15a60299c6199d102">tcpip_inpkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a12bdf37eddcd72c4178e3ea7d370395d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_send_msg_wait_sem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>apimsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sys_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to TCPIP thread to call a function. </p>
<p>Caller thread blocks on on a provided semaphore, which ist NOT automatically signalled by TCPIP thread, this has to be done by the user. It is recommended to use LWIP_TCPIP_CORE_LOCKING since this is the way with least runtime overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>function to be called from TCPIP thread </td></tr>
    <tr><td class="paramname">apimsg</td><td>argument to API function </td></tr>
    <tr><td class="paramname">sem</td><td>semaphore to wait on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if the function was called, another err_t if not </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="group__compiler__abstraction.html#ga70624a5deb8b9199406372a7f3603ecf">LWIP_UNUSED_ARG</a>, <a class="el" href="group__sys__sem.html#ga8d364c5037778acb21c3df675db81b4f">sys_arch_sem_wait()</a>, <a class="el" href="group__sys__mbox.html#ga9d068386a3c53dd01b8af99c3ef77555">sys_mbox_post()</a>, <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>, and <a class="el" href="group__sys__sem.html#ga09a6c052ddaf799139efc56adfa087e4">sys_sem_valid()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb7b3c7414c76ad8dde14d2fba6cb020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcpip_try_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tcpip_8h.html#a18688a49d64108e9f3c807e57b72265f">tcpip_callback_fn</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a specific function in the thread context of tcpip_thread for easy access synchronization. </p>
<p>A function called in that way may access lwIP core code without fearing concurrent access. Does NOT block when the request cannot be posted because the tcpip_mbox is full, but returns ERR_MEM instead. Can be called from interrupt context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the function to call </td></tr>
    <tr><td class="paramname">ctx</td><td>parameter passed to f </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if the function was called, another err_t if not</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="tcpip_8h.html#aab838fe3417ab3a1f61f0728009a0c2a" title="Call a specific function in the thread context of tcpip_thread for easy access synchronization. ">tcpip_callback</a> </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaaaeafdbf3aecc46864daa3cd829c7e05">ERR_MEM</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free()</a>, <a class="el" href="group__sys__mbox.html#gaa36345e48a49d67cbb0878cd4cbd2195">sys_mbox_trypost()</a>, and <a class="el" href="sys_8h.html#aae82640d0bdbeec7b9b6511b3f8d99cb">sys_mbox_valid_val</a>.</p>

<p>Referenced by <a class="el" href="tcpip_8h.html#a55b4de3765c6a37b3f2b26a11603771c">mem_free_callback()</a>, and <a class="el" href="tcpip_8h.html#a5cdcb6b784fe0e8736a5b31a5cfbed6c">pbuf_free_callback()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
