<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>lwip211: Packet buffers (PBUF)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">lwip211
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__pbuf.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Packet buffers (PBUF)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga894d91d811fd986f3cc3da828fa7beb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga894d91d811fd986f3cc3da828fa7beb3">PBUF_NEEDS_COPY</a>(p)&#160;&#160;&#160;((p)-&gt;type_internal &amp; <a class="el" href="pbuf_8h.html#a02789ca67766def65000b58f7fe7d03b">PBUF_TYPE_FLAG_DATA_VOLATILE</a>)</td></tr>
<tr class="memdesc:ga894d91d811fd986f3cc3da828fa7beb3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__pbuf.html#ga894d91d811fd986f3cc3da828fa7beb3" title="PBUF_NEEDS_COPY(p): return a boolean value indicating whether the given pbuf needs to be copied in or...">PBUF_NEEDS_COPY(p)</a>: return a boolean value indicating whether the given pbuf needs to be copied in order to be kept around beyond the current call stack without risking being corrupted.  <a href="#ga894d91d811fd986f3cc3da828fa7beb3">More...</a><br/></td></tr>
<tr class="separator:ga894d91d811fd986f3cc3da828fa7beb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaee1baa59bb2f85ba575b5a8619ac1ebf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> { <br/>
&#160;&#160;<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5">PBUF_TRANSPORT</a> = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN, 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13">PBUF_IP</a> = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN, 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346">PBUF_LINK</a> = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN, 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2">PBUF_RAW_TX</a> = PBUF_LINK_ENCAPSULATION_HLEN, 
<br/>
&#160;&#160;<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba">PBUF_RAW</a> = 0
<br/>
 }</td></tr>
<tr class="memdesc:gaee1baa59bb2f85ba575b5a8619ac1ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of pbuf layers.  <a href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">More...</a><br/></td></tr>
<tr class="separator:gaee1baa59bb2f85ba575b5a8619ac1ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e0e32fcc292c0d7107721766ed92fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> { <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab">PBUF_RAM</a> = (PBUF_ALLOC_FLAG_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP), 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9">PBUF_ROM</a> = PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF, 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e">PBUF_REF</a> = (PBUF_TYPE_FLAG_DATA_VOLATILE | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF), 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21">PBUF_POOL</a> = (PBUF_ALLOC_FLAG_RX | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL)
 }</td></tr>
<tr class="memdesc:gab7e0e32fcc292c0d7107721766ed92fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of pbuf types.  <a href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">More...</a><br/></td></tr>
<tr class="separator:gab7e0e32fcc292c0d7107721766ed92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacfcb0a2af918658ba0afe36499c65f47"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a> (<a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> layer, u16_t length, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type)</td></tr>
<tr class="memdesc:gacfcb0a2af918658ba0afe36499c65f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type).  <a href="#gacfcb0a2af918658ba0afe36499c65f47">More...</a><br/></td></tr>
<tr class="separator:gacfcb0a2af918658ba0afe36499c65f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4caa46c6d560d9d0da2be845bc9c2fab"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga4caa46c6d560d9d0da2be845bc9c2fab">pbuf_alloc_reference</a> (void *payload, u16_t length, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type)</td></tr>
<tr class="memdesc:ga4caa46c6d560d9d0da2be845bc9c2fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a pbuf for referenced data.  <a href="#ga4caa46c6d560d9d0da2be845bc9c2fab">More...</a><br/></td></tr>
<tr class="separator:ga4caa46c6d560d9d0da2be845bc9c2fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50abfe830a33a1a47a562febee66015d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga50abfe830a33a1a47a562febee66015d">pbuf_realloc</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t new_len)</td></tr>
<tr class="memdesc:ga50abfe830a33a1a47a562febee66015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a pbuf chain to a desired length.  <a href="#ga50abfe830a33a1a47a562febee66015d">More...</a><br/></td></tr>
<tr class="separator:ga50abfe830a33a1a47a562febee66015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0dd696fb4b6bc65e548944584f1738b"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="memdesc:gab0dd696fb4b6bc65e548944584f1738b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a pbuf chain or queue and deallocate any no-longer-used pbufs at the head of this chain or queue.  <a href="#gab0dd696fb4b6bc65e548944584f1738b">More...</a><br/></td></tr>
<tr class="separator:gab0dd696fb4b6bc65e548944584f1738b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f6bbd69e45e542014d9c547c7da74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga77f6bbd69e45e542014d9c547c7da74e">pbuf_ref</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="memdesc:ga77f6bbd69e45e542014d9c547c7da74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count of the pbuf.  <a href="#ga77f6bbd69e45e542014d9c547c7da74e">More...</a><br/></td></tr>
<tr class="separator:ga77f6bbd69e45e542014d9c547c7da74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82429084fe29015509c9b4a072707cd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga82429084fe29015509c9b4a072707cd4">pbuf_cat</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *h, struct <a class="el" href="structpbuf.html">pbuf</a> *t)</td></tr>
<tr class="memdesc:ga82429084fe29015509c9b4a072707cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two pbufs (each may be a pbuf chain) and take over the caller's reference of the tail pbuf.  <a href="#ga82429084fe29015509c9b4a072707cd4">More...</a><br/></td></tr>
<tr class="separator:ga82429084fe29015509c9b4a072707cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831c9a72bda1d3bd4c7b96f5a0e3b891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *h, struct <a class="el" href="structpbuf.html">pbuf</a> *t)</td></tr>
<tr class="memdesc:ga831c9a72bda1d3bd4c7b96f5a0e3b891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain two pbufs (or pbuf chains) together.  <a href="#ga831c9a72bda1d3bd4c7b96f5a0e3b891">More...</a><br/></td></tr>
<tr class="separator:ga831c9a72bda1d3bd4c7b96f5a0e3b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba88511dee3df4b631fde691f421320d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaba88511dee3df4b631fde691f421320d">pbuf_copy</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p_to, const struct <a class="el" href="structpbuf.html">pbuf</a> *p_from)</td></tr>
<tr class="memdesc:gaba88511dee3df4b631fde691f421320d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create PBUF_RAM copies of pbufs.  <a href="#gaba88511dee3df4b631fde691f421320d">More...</a><br/></td></tr>
<tr class="separator:gaba88511dee3df4b631fde691f421320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f1f58fd36042e82af46f5015720899"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gac2f1f58fd36042e82af46f5015720899">pbuf_copy_partial</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *buf, void *dataptr, u16_t len, u16_t offset)</td></tr>
<tr class="memdesc:gac2f1f58fd36042e82af46f5015720899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (part of) the contents of a packet buffer to an application supplied buffer.  <a href="#gac2f1f58fd36042e82af46f5015720899">More...</a><br/></td></tr>
<tr class="separator:gac2f1f58fd36042e82af46f5015720899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0357ae0be17b2aacd0c301cdc86fc39"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gad0357ae0be17b2aacd0c301cdc86fc39">pbuf_get_contiguous</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, void *buffer, size_t bufsize, u16_t len, u16_t offset)</td></tr>
<tr class="memdesc:gad0357ae0be17b2aacd0c301cdc86fc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a pbuf's payload as contiguous memory.  <a href="#gad0357ae0be17b2aacd0c301cdc86fc39">More...</a><br/></td></tr>
<tr class="separator:gad0357ae0be17b2aacd0c301cdc86fc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a961522d81f0327aaf4d4ee6d96c583"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga6a961522d81f0327aaf4d4ee6d96c583">pbuf_skip</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *in, u16_t in_offset, u16_t *out_offset)</td></tr>
<tr class="memdesc:ga6a961522d81f0327aaf4d4ee6d96c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip a number of bytes at the start of a pbuf.  <a href="#ga6a961522d81f0327aaf4d4ee6d96c583">More...</a><br/></td></tr>
<tr class="separator:ga6a961522d81f0327aaf4d4ee6d96c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e31e370271335b197272af2724ca85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gad1e31e370271335b197272af2724ca85">pbuf_take</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, const void *dataptr, u16_t len)</td></tr>
<tr class="memdesc:gad1e31e370271335b197272af2724ca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy application supplied data into a pbuf.  <a href="#gad1e31e370271335b197272af2724ca85">More...</a><br/></td></tr>
<tr class="separator:gad1e31e370271335b197272af2724ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf2bf7454ff87ff377b0b2262f9b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gae1cf2bf7454ff87ff377b0b2262f9b44">pbuf_take_at</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, const void *dataptr, u16_t len, u16_t offset)</td></tr>
<tr class="memdesc:gae1cf2bf7454ff87ff377b0b2262f9b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__pbuf.html#gad1e31e370271335b197272af2724ca85" title="Copy application supplied data into a pbuf. ">pbuf_take()</a> but puts data at an offset.  <a href="#gae1cf2bf7454ff87ff377b0b2262f9b44">More...</a><br/></td></tr>
<tr class="separator:gae1cf2bf7454ff87ff377b0b2262f9b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ac7b116c6f53c704cbf74f35a8b35c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga54ac7b116c6f53c704cbf74f35a8b35c">pbuf_coalesce</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> layer)</td></tr>
<tr class="memdesc:ga54ac7b116c6f53c704cbf74f35a8b35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single pbuf out of a queue of pbufs.  <a href="#ga54ac7b116c6f53c704cbf74f35a8b35c">More...</a><br/></td></tr>
<tr class="separator:ga54ac7b116c6f53c704cbf74f35a8b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb04fb0f37f0422fd44ec0fcec8ebd0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gafdb04fb0f37f0422fd44ec0fcec8ebd0">pbuf_clone</a> (<a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> layer, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type, struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="memdesc:gafdb04fb0f37f0422fd44ec0fcec8ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new pbuf of same length (via <a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47" title="Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type). ">pbuf_alloc()</a>) and copies the source pbuf into this new pbuf (using <a class="el" href="group__pbuf.html#gaba88511dee3df4b631fde691f421320d" title="Create PBUF_RAM copies of pbufs. ">pbuf_copy()</a>).  <a href="#gafdb04fb0f37f0422fd44ec0fcec8ebd0">More...</a><br/></td></tr>
<tr class="separator:gafdb04fb0f37f0422fd44ec0fcec8ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d803d9945bffb7ad97743f2fa503da6"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga6d803d9945bffb7ad97743f2fa503da6">pbuf_get_at</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset)</td></tr>
<tr class="memdesc:ga6d803d9945bffb7ad97743f2fa503da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one byte from the specified position in a pbuf WARNING: returns zero for offset &gt;= p-&gt;tot_len.  <a href="#ga6d803d9945bffb7ad97743f2fa503da6">More...</a><br/></td></tr>
<tr class="separator:ga6d803d9945bffb7ad97743f2fa503da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839f342803b0cf89049744124c5a98ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga839f342803b0cf89049744124c5a98ad">pbuf_try_get_at</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset)</td></tr>
<tr class="memdesc:ga839f342803b0cf89049744124c5a98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one byte from the specified position in a pbuf.  <a href="#ga839f342803b0cf89049744124c5a98ad">More...</a><br/></td></tr>
<tr class="separator:ga839f342803b0cf89049744124c5a98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76863707dc02993eae116574b1ea03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaf76863707dc02993eae116574b1ea03f">pbuf_put_at</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset, u8_t data)</td></tr>
<tr class="memdesc:gaf76863707dc02993eae116574b1ea03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put one byte to the specified position in a pbuf WARNING: silently ignores offset &gt;= p-&gt;tot_len.  <a href="#gaf76863707dc02993eae116574b1ea03f">More...</a><br/></td></tr>
<tr class="separator:gaf76863707dc02993eae116574b1ea03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2170ccbbb13238380dbb203ee1b85974"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga2170ccbbb13238380dbb203ee1b85974">pbuf_memcmp</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset, const void *s2, u16_t n)</td></tr>
<tr class="memdesc:ga2170ccbbb13238380dbb203ee1b85974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare pbuf contents at specified offset with memory s2, both of length n.  <a href="#ga2170ccbbb13238380dbb203ee1b85974">More...</a><br/></td></tr>
<tr class="separator:ga2170ccbbb13238380dbb203ee1b85974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c164a6e4a24d89ea9eb7571a886448"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga18c164a6e4a24d89ea9eb7571a886448">pbuf_memfind</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, const void *mem, u16_t mem_len, u16_t start_offset)</td></tr>
<tr class="memdesc:ga18c164a6e4a24d89ea9eb7571a886448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find occurrence of mem (with length mem_len) in pbuf p, starting at offset start_offset.  <a href="#ga18c164a6e4a24d89ea9eb7571a886448">More...</a><br/></td></tr>
<tr class="separator:ga18c164a6e4a24d89ea9eb7571a886448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga894d91d811fd986f3cc3da828fa7beb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_NEEDS_COPY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td>&#160;&#160;&#160;((p)-&gt;type_internal &amp; <a class="el" href="pbuf_8h.html#a02789ca67766def65000b58f7fe7d03b">PBUF_TYPE_FLAG_DATA_VOLATILE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__pbuf.html#ga894d91d811fd986f3cc3da828fa7beb3" title="PBUF_NEEDS_COPY(p): return a boolean value indicating whether the given pbuf needs to be copied in or...">PBUF_NEEDS_COPY(p)</a>: return a boolean value indicating whether the given pbuf needs to be copied in order to be kept around beyond the current call stack without risking being corrupted. </p>
<p>The default setting provides safety: it will make a copy iof any pbuf chain that does not consist entirely of PBUF_ROM type pbufs. For setups with zero-copy support, it may be redefined to evaluate to true in all cases, for example. However, doing so also has an effect on the application side: any buffers that are <em>not</em> copied must also <em>not</em> be reused by the application after passing them to lwIP. For example, when setting PBUF_NEEDS_COPY to (0), after using udp_send() with a PBUF_RAM pbuf, the application must free the pbuf immediately, rather than reusing it for other purposes. For more background information on this, see tasks #6735 and #7896, and bugs #11400 and #49914. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaee1baa59bb2f85ba575b5a8619ac1ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of pbuf layers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5"></a>PBUF_TRANSPORT</em>&nbsp;</td><td class="fielddoc">
<p>Includes spare room for transport layer header, e.g. </p>
<p>UDP header. Use this if you intend to pass the pbuf to functions like udp_send(). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13"></a>PBUF_IP</em>&nbsp;</td><td class="fielddoc">
<p>Includes spare room for IP header. </p>
<p>Use this if you intend to pass the pbuf to functions like raw_send(). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346"></a>PBUF_LINK</em>&nbsp;</td><td class="fielddoc">
<p>Includes spare room for link layer header (ethernet header). </p>
<p>Use this if you intend to pass the pbuf to functions like ethernet_output(). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lwip__opts__pbuf.html#ga35998a3d56af9940e6a80bb372597685" title="PBUF_LINK_HLEN: the number of bytes that should be allocated for a link level header. ">PBUF_LINK_HLEN</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2"></a>PBUF_RAW_TX</em>&nbsp;</td><td class="fielddoc">
<p>Includes spare room for additional encapsulation header before ethernet headers (e.g. </p>
<p>802.11). Use this if you intend to pass the pbuf to functions like netif-&gt;linkoutput(). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lwip__opts__pbuf.html#ga6e1ba1875ae5168a17b53d83597bc1de" title="PBUF_LINK_ENCAPSULATION_HLEN: the number of bytes that should be allocated for an additional encapsul...">PBUF_LINK_ENCAPSULATION_HLEN</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba"></a>PBUF_RAW</em>&nbsp;</td><td class="fielddoc">
<p>Use this for input packets in a netif driver when calling netif-&gt;input() in the most common case - ethernet-layer netif driver. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab7e0e32fcc292c0d7107721766ed92fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of pbuf types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab"></a>PBUF_RAM</em>&nbsp;</td><td class="fielddoc">
<p>pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload are allocated in one piece of contiguous memory (so the first payload byte can be calculated from struct pbuf). </p>
<p><a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47" title="Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type). ">pbuf_alloc()</a> allocates PBUF_RAM pbufs as unchained pbufs (although that might change in future versions). This should be used for all OUTGOING packets (TX). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9"></a>PBUF_ROM</em>&nbsp;</td><td class="fielddoc">
<p>pbuf data is stored in ROM, i.e. </p>
<p>struct pbuf and its payload are located in totally different memory areas. Since it points to ROM, payload does not have to be copied when queued for transmission. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e"></a>PBUF_REF</em>&nbsp;</td><td class="fielddoc">
<p>pbuf comes from the pbuf pool. </p>
<p>Much like PBUF_ROM but payload might change so it has to be duplicated when queued before transmitting, depending on who has a 'ref' to it. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21"></a>PBUF_POOL</em>&nbsp;</td><td class="fielddoc">
<p>pbuf payload refers to RAM. </p>
<p>This one comes from a pool and should be used for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct pbuf and its payload are allocated in one piece of contiguous memory (so the first payload byte can be calculated from struct pbuf). Don't use this for TX, if the pool becomes empty e.g. because of TCP queuing, you are unable to receive TCP acks! </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacfcb0a2af918658ba0afe36499c65f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a>&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type). </p>
<p>The actual memory allocated for the pbuf is determined by the layer at which the pbuf is allocated and the requested size (from the size parameter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>header size </td></tr>
    <tr><td class="paramname">length</td><td>size of the pbuf's payload </td></tr>
    <tr><td class="paramname">type</td><td>this parameter decides how and where the pbuf should be allocated as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>PBUF_RAM: buffer memory for pbuf is allocated as one large chunk. This includes protocol headers as well.</li>
<li>PBUF_ROM: no buffer memory is allocated for the pbuf, even for protocol headers. Additional headers must be prepended by allocating another pbuf and chain in to the front of the ROM pbuf. It is assumed that the memory used is really similar to ROM in that it is immutable and will not be changed. Memory which is dynamic should generally not be attached to PBUF_ROM pbufs. Use PBUF_REF instead.</li>
<li>PBUF_REF: no buffer memory is allocated for the pbuf, even for protocol headers. It is assumed that the pbuf is only being used in a single thread. If the pbuf gets queued, then pbuf_take should be called to copy the buffer.</li>
<li>PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from the pbuf pool that is allocated during pbuf_init().</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the allocated pbuf. If multiple pbufs where allocated, this is the first pbuf of a pbuf chain. </dd></dl>

<p>References <a class="el" href="group__debugging__levels.html#ga988147559b78642ac881815b66023646">LWIP_DBG_TRACE</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="group__compiler__abstraction.html#gaa8e8724eb1c220cbbb90de9e175ce1dc">LWIP_MEM_ALIGN</a>, <a class="el" href="group__compiler__abstraction.html#gaef204be511fd32f681b55abc08e9ae18">LWIP_MEM_ALIGN_SIZE</a>, <a class="el" href="group__lwip__opts__mem.html#ga97343214666ee6dcb18c0bd77b441ea7">MEM_ALIGNMENT</a>, <a class="el" href="mem_8c.html#af418ade27d91d41e6143dba2cc246b0f">mem_malloc()</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, <a class="el" href="group__pbuf.html#ga4caa46c6d560d9d0da2be845bc9c2fab">pbuf_alloc_reference()</a>, <a class="el" href="group__lwip__opts__debugmsg.html#ga5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>, <a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free()</a>, <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21">PBUF_POOL</a>, <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab">PBUF_RAM</a>, <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e">PBUF_REF</a>, and <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9">PBUF_ROM</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gafdb04fb0f37f0422fd44ec0fcec8ebd0">pbuf_clone()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4caa46c6d560d9d0da2be845bc9c2fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_alloc_reference </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a pbuf for referenced data. </p>
<p>Referenced data can be volatile (PBUF_REF) or long-lived (PBUF_ROM).</p>
<p>The actual memory allocated for the pbuf is determined by the layer at which the pbuf is allocated and the requested size (from the size parameter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>referenced payload </td></tr>
    <tr><td class="paramname">length</td><td>size of the pbuf's payload </td></tr>
    <tr><td class="paramname">type</td><td>this parameter decides how and where the pbuf should be allocated as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>PBUF_ROM: It is assumed that the memory used is really similar to ROM in that it is immutable and will not be changed. Memory which is dynamic should generally not be attached to PBUF_ROM pbufs. Use PBUF_REF instead.</li>
<li>PBUF_REF: It is assumed that the pbuf is only being used in a single thread. If the pbuf gets queued, then pbuf_take should be called to copy the buffer.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the allocated pbuf. </dd></dl>

<p>References <a class="el" href="group__debugging__levels.html#ga0269bdc51f1e8a5ecf9af72c6e1c996c">LWIP_DBG_LEVEL_SERIOUS</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="group__lwip__opts__debugmsg.html#ga5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>, <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e">PBUF_REF</a>, and <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9">PBUF_ROM</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47">pbuf_alloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82429084fe29015509c9b4a072707cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_cat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two pbufs (each may be a pbuf chain) and take over the caller's reference of the tail pbuf. </p>
<dl class="section note"><dt>Note</dt><dd>The caller MAY NOT reference the tail pbuf afterwards. Use <a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891" title="Chain two pbufs (or pbuf chains) together. ">pbuf_chain()</a> for that purpose.</dd></dl>
<p>This function explicitly does not check for tot_len overflow to prevent failing to queue too long pbufs. This can produce invalid pbufs, so handle with care!</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891" title="Chain two pbufs (or pbuf chains) together. ">pbuf_chain()</a> </dd></dl>

<p>References <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="memp_8c.html#afc13346393076cb9449a23d2b6870fa2">LWIP_ERROR()</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain()</a>.</p>

</div>
</div>
<a class="anchor" id="ga831c9a72bda1d3bd4c7b96f5a0e3b891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain two pbufs (or pbuf chains) together. </p>
<p>The caller MUST call pbuf_free(t) once it has stopped using it. Use <a class="el" href="group__pbuf.html#ga82429084fe29015509c9b4a072707cd4" title="Concatenate two pbufs (each may be a pbuf chain) and take over the caller&#39;s reference of the tail pbu...">pbuf_cat()</a> instead if you no longer use t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>head pbuf (chain) </td></tr>
    <tr><td class="paramname">t</td><td>tail pbuf (chain) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pbufs MUST belong to the same packet. </dd>
<dd>
MAY NOT be called on a packet queue.</dd></dl>
<p>The -&gt;tot_len fields of all pbufs of the head chain are adjusted. The -&gt;next field of the last pbuf of the head chain is adjusted. The -&gt;ref field of the first pbuf of the tail chain is adjusted. </p>

<p>References <a class="el" href="group__debugging__levels.html#ga988147559b78642ac881815b66023646">LWIP_DBG_TRACE</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="group__pbuf.html#ga82429084fe29015509c9b4a072707cd4">pbuf_cat()</a>, <a class="el" href="group__lwip__opts__debugmsg.html#ga5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>, and <a class="el" href="group__pbuf.html#ga77f6bbd69e45e542014d9c547c7da74e">pbuf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="gafdb04fb0f37f0422fd44ec0fcec8ebd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a>&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new pbuf of same length (via <a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47" title="Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type). ">pbuf_alloc()</a>) and copies the source pbuf into this new pbuf (using <a class="el" href="group__pbuf.html#gaba88511dee3df4b631fde691f421320d" title="Create PBUF_RAM copies of pbufs. ">pbuf_copy()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>pbuf_layer of the new pbuf </td></tr>
    <tr><td class="paramname">type</td><td>this parameter decides how and where the pbuf should be allocated (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47" title="Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type). ">pbuf_alloc()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the source pbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new pbuf or NULL if allocation fails </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="group__compiler__abstraction.html#ga70624a5deb8b9199406372a7f3603ecf">LWIP_UNUSED_ARG</a>, <a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47">pbuf_alloc()</a>, <a class="el" href="group__pbuf.html#gaba88511dee3df4b631fde691f421320d">pbuf_copy()</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga54ac7b116c6f53c704cbf74f35a8b35c">pbuf_coalesce()</a>.</p>

</div>
</div>
<a class="anchor" id="ga54ac7b116c6f53c704cbf74f35a8b35c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_coalesce </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a>&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single pbuf out of a queue of pbufs. </p>
<dl class="section remark"><dt>Remarks</dt><dd>: Either the source pbuf 'p' is freed by this function or the original pbuf 'p' is returned, therefore the caller has to check the result!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the source pbuf </td></tr>
    <tr><td class="paramname">layer</td><td>pbuf_layer of the new pbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new, single pbuf (p-&gt;next is NULL) or the old pbuf if allocation fails </dd></dl>

<p>References <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="group__pbuf.html#gafdb04fb0f37f0422fd44ec0fcec8ebd0">pbuf_clone()</a>, <a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free()</a>, and <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab">PBUF_RAM</a>.</p>

</div>
</div>
<a class="anchor" id="gaba88511dee3df4b631fde691f421320d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> pbuf_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p_from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create PBUF_RAM copies of pbufs. </p>
<p>Used to queue packets on behalf of the lwIP stack, such as ARP based queueing.</p>
<dl class="section note"><dt>Note</dt><dd>You MUST explicitly use p = pbuf_take(p);</dd>
<dd>
Only one packet is copied, no packet queue!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_to</td><td>pbuf destination of the copy </td></tr>
    <tr><td class="paramname">p_from</td><td>pbuf source of the copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if pbuf was copied ERR_ARG if one of the pbufs is NULL or p_to is not big enough to hold p_from </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcab508ce0ebdf3ca735208b00a80a45c91">ERR_ARG</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa9a1c5a6fdeed0aad7fe41d538482bbd">ERR_VAL</a>, <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="group__debugging__levels.html#ga988147559b78642ac881815b66023646">LWIP_DBG_TRACE</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="memp_8c.html#afc13346393076cb9449a23d2b6870fa2">LWIP_ERROR()</a>, <a class="el" href="group__lwip__opts__memcpy.html#gaa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, <a class="el" href="group__lwip__opts__debugmsg.html#ga5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gafdb04fb0f37f0422fd44ec0fcec8ebd0">pbuf_clone()</a>.</p>

</div>
</div>
<a class="anchor" id="gac2f1f58fd36042e82af46f5015720899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t pbuf_copy_partial </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy (part of) the contents of a packet buffer to an application supplied buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the pbuf from which to copy data </td></tr>
    <tr><td class="paramname">dataptr</td><td>the application supplied buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of data to copy (dataptr must be big enough). No more than buf-&gt;tot_len will be copied, irrespective of len </td></tr>
    <tr><td class="paramname">offset</td><td>offset into the packet buffer from where to begin copying len bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes copied, or 0 on failure </dd></dl>

<p>References <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="memp_8c.html#afc13346393076cb9449a23d2b6870fa2">LWIP_ERROR()</a>, <a class="el" href="group__lwip__opts__memcpy.html#gaa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, and <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gad0357ae0be17b2aacd0c301cdc86fc39">pbuf_get_contiguous()</a>.</p>

</div>
</div>
<a class="anchor" id="gab0dd696fb4b6bc65e548944584f1738b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference a pbuf chain or queue and deallocate any no-longer-used pbufs at the head of this chain or queue. </p>
<p>Decrements the pbuf reference count. If it reaches zero, the pbuf is deallocated.</p>
<p>For a pbuf chain, this is repeated for each pbuf in the chain, up to the first pbuf which has a non-zero reference count after decrementing. So, when all reference counts are one, the whole chain is free'd.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pbuf (chain) to be dereferenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pbufs that were de-allocated from the head of the chain.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>MUST NOT be called on a packet queue (Not verified to work yet). </dd>
<dd>
the reference counter of a pbuf equals the number of pointers that refer to the pbuf (or into the pbuf). </dd></dl>

<p>References <a class="el" href="structpbuf.html#aa4d1af2cab3d9280d29212095b5b872a">flags</a>, <a class="el" href="group__debugging__levels.html#ga0269bdc51f1e8a5ecf9af72c6e1c996c">LWIP_DBG_LEVEL_SERIOUS</a>, <a class="el" href="group__debugging__levels.html#ga988147559b78642ac881815b66023646">LWIP_DBG_TRACE</a>, <a class="el" href="debug_8h.html#a63a04edf7ff63c951bd8706711956cdb">LWIP_DEBUGF</a>, <a class="el" href="group__lwip__opts__pbuf.html#gaaefb80d6bf9257c0f4322c36e1272c38">LWIP_PBUF_REF_T</a>, <a class="el" href="mem_8c.html#a65169147c44e9db60d997819af9b455c">mem_free()</a>, <a class="el" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free()</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="group__lwip__opts__debugmsg.html#ga5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>, <a class="el" href="pbuf_8h.html#af78a7e1815dc0e31884d095b666d997f">PBUF_FLAG_IS_CUSTOM</a>, <a class="el" href="structpbuf.html#a22fe667d2df4046e9f55aed5b4dd171c">ref</a>, and <a class="el" href="sys_8h.html#a945395fa326214fc9736487242710a90">SYS_ARCH_DECL_PROTECT</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47">pbuf_alloc()</a>, <a class="el" href="group__pbuf.html#ga54ac7b116c6f53c704cbf74f35a8b35c">pbuf_coalesce()</a>, <a class="el" href="pbuf_8h.html#abf3d29c4f43986b4cb5eb314d5b9729d">pbuf_dechain()</a>, <a class="el" href="pbuf_8h.html#a25a3b8edc783896b03819a966d00845e">pbuf_free_header()</a>, and <a class="el" href="group__pbuf.html#ga50abfe830a33a1a47a562febee66015d">pbuf_realloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d803d9945bffb7ad97743f2fa503da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_get_at </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one byte from the specified position in a pbuf WARNING: returns zero for offset &gt;= p-&gt;tot_len. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to parse </td></tr>
    <tr><td class="paramname">offset</td><td>offset into p of the byte to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte at an offset into p OR ZERO IF 'offset' &gt;= p-&gt;tot_len </dd></dl>

<p>References <a class="el" href="group__pbuf.html#ga839f342803b0cf89049744124c5a98ad">pbuf_try_get_at()</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga2170ccbbb13238380dbb203ee1b85974">pbuf_memcmp()</a>.</p>

</div>
</div>
<a class="anchor" id="gad0357ae0be17b2aacd0c301cdc86fc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pbuf_get_contiguous </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get part of a pbuf's payload as contiguous memory. </p>
<p>The returned memory is either a pointer into the pbuf's payload or, if split over multiple pbufs, a copy into the user-supplied buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pbuf from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>the application supplied buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>size of the application supplied buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of data to copy (dataptr must be big enough). No more than buf-&gt;tot_len will be copied, irrespective of len </td></tr>
    <tr><td class="paramname">offset</td><td>offset into the packet buffer from where to begin copying len bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes copied, or 0 on failure </dd></dl>

<p>References <a class="el" href="memp_8c.html#afc13346393076cb9449a23d2b6870fa2">LWIP_ERROR()</a>, and <a class="el" href="group__pbuf.html#gac2f1f58fd36042e82af46f5015720899">pbuf_copy_partial()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2170ccbbb13238380dbb203ee1b85974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t pbuf_memcmp </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare pbuf contents at specified offset with memory s2, both of length n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to compare </td></tr>
    <tr><td class="paramname">offset</td><td>offset into p at which to start comparing </td></tr>
    <tr><td class="paramname">s2</td><td>buffer to compare </td></tr>
    <tr><td class="paramname">n</td><td>length of buffer to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if equal, nonzero otherwise (0xffff if p is too short, diffoffset+1 otherwise) </dd></dl>

<p>References <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="group__pbuf.html#ga6d803d9945bffb7ad97743f2fa503da6">pbuf_get_at()</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga18c164a6e4a24d89ea9eb7571a886448">pbuf_memfind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18c164a6e4a24d89ea9eb7571a886448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t pbuf_memfind </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>mem_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>start_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find occurrence of mem (with length mem_len) in pbuf p, starting at offset start_offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to search, maximum length is 0xFFFE since 0xFFFF is used as return value 'not found' </td></tr>
    <tr><td class="paramname">mem</td><td>search for the contents of this buffer </td></tr>
    <tr><td class="paramname">mem_len</td><td>length of 'mem' </td></tr>
    <tr><td class="paramname">start_offset</td><td>offset into p at which to start searching </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0xFFFF if substr was not found in p or the index where it was found </dd></dl>

<p>References <a class="el" href="group__pbuf.html#ga2170ccbbb13238380dbb203ee1b85974">pbuf_memcmp()</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="pbuf_8h.html#a9ba3f7b705309ceadb147692fd5a1c7d">pbuf_strstr()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76863707dc02993eae116574b1ea03f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_put_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put one byte to the specified position in a pbuf WARNING: silently ignores offset &gt;= p-&gt;tot_len. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to fill </td></tr>
    <tr><td class="paramname">offset</td><td>offset into p of the byte to write </td></tr>
    <tr><td class="paramname">data</td><td>byte to write at an offset into p </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, and <a class="el" href="group__pbuf.html#ga6a961522d81f0327aaf4d4ee6d96c583">pbuf_skip()</a>.</p>

</div>
</div>
<a class="anchor" id="ga50abfe830a33a1a47a562febee66015d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_realloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>new_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a pbuf chain to a desired length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to shrink. </td></tr>
    <tr><td class="paramname">new_len</td><td>desired new length of pbuf chain</td></tr>
  </table>
  </dd>
</dl>
<p>Depending on the desired length, the first few pbufs in a chain might be skipped and left unchanged. The new last pbuf in the chain will be resized, and any remaining pbufs will be freed.</p>
<dl class="section note"><dt>Note</dt><dd>If the pbuf is ROM/REF, only the -&gt;tot_len and -&gt;len fields are adjusted. </dd>
<dd>
May not be called on a packet queue.</dd>
<dd>
Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain). </dd></dl>

<p>References <a class="el" href="structpbuf.html#aa4d1af2cab3d9280d29212095b5b872a">flags</a>, <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="pbuf_8h.html#a64174c5169b48dc17674324afd9c63b9">LWIP_SUPPORT_CUSTOM_PBUF</a>, <a class="el" href="mem_8c.html#a7e6b7f11bb50bead9b35515d9a517124">mem_trim()</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, <a class="el" href="pbuf_8h.html#af78a7e1815dc0e31884d095b666d997f">PBUF_FLAG_IS_CUSTOM</a>, <a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free()</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

</div>
</div>
<a class="anchor" id="ga77f6bbd69e45e542014d9c547c7da74e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the reference count of the pbuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to increase reference counter of </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__lwip__opts__pbuf.html#gaaefb80d6bf9257c0f4322c36e1272c38">LWIP_PBUF_REF_T</a>, and <a class="el" href="structpbuf.html#a22fe667d2df4046e9f55aed5b4dd171c">ref</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a961522d81f0327aaf4d4ee6d96c583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_skip </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>in_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t *&#160;</td>
          <td class="paramname"><em>out_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip a number of bytes at the start of a pbuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input pbuf </td></tr>
    <tr><td class="paramname">in_offset</td><td>offset to skip </td></tr>
    <tr><td class="paramname">out_offset</td><td>resulting offset in the returned pbuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pbuf in the queue where the offset is </dd></dl>

<p>References <a class="el" href="group__compiler__abstraction.html#gaa0dd3f76dd9a837feaac61fedc0dbe72">LWIP_CONST_CAST</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gaf76863707dc02993eae116574b1ea03f">pbuf_put_at()</a>, and <a class="el" href="group__pbuf.html#gae1cf2bf7454ff87ff377b0b2262f9b44">pbuf_take_at()</a>.</p>

</div>
</div>
<a class="anchor" id="gad1e31e370271335b197272af2724ca85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> pbuf_take </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy application supplied data into a pbuf. </p>
<p>This function can only be used to copy the equivalent of buf-&gt;tot_len data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pbuf to fill with data </td></tr>
    <tr><td class="paramname">dataptr</td><td>application supplied data buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of the application supplied data buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if successful, ERR_MEM if the pbuf is not big enough </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcab508ce0ebdf3ca735208b00a80a45c91">ERR_ARG</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaaaeafdbf3aecc46864daa3cd829c7e05">ERR_MEM</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="memp_8c.html#afc13346393076cb9449a23d2b6870fa2">LWIP_ERROR()</a>, <a class="el" href="group__lwip__opts__memcpy.html#gaa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#gae1cf2bf7454ff87ff377b0b2262f9b44">pbuf_take_at()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1cf2bf7454ff87ff377b0b2262f9b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> pbuf_take_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__pbuf.html#gad1e31e370271335b197272af2724ca85" title="Copy application supplied data into a pbuf. ">pbuf_take()</a> but puts data at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pbuf to fill with data </td></tr>
    <tr><td class="paramname">dataptr</td><td>application supplied data buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of the application supplied data buffer </td></tr>
    <tr><td class="paramname">offset</td><td>offset in pbuf where to copy dataptr to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if successful, ERR_MEM if the pbuf is not big enough </dd></dl>

<p>References <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaaaeafdbf3aecc46864daa3cd829c7e05">ERR_MEM</a>, <a class="el" href="group__infrastructure__errors.html#ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a>, <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, <a class="el" href="group__lwip__opts__memcpy.html#gaa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>, <a class="el" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>, <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>, <a class="el" href="group__pbuf.html#ga6a961522d81f0327aaf4d4ee6d96c583">pbuf_skip()</a>, <a class="el" href="group__pbuf.html#gad1e31e370271335b197272af2724ca85">pbuf_take()</a>, and <a class="el" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>.</p>

</div>
</div>
<a class="anchor" id="ga839f342803b0cf89049744124c5a98ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pbuf_try_get_at </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one byte from the specified position in a pbuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to parse </td></tr>
    <tr><td class="paramname">offset</td><td>offset into p of the byte to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte at an offset into p [0..0xFF] OR negative if 'offset' &gt;= p-&gt;tot_len </dd></dl>

<p>References <a class="el" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>, and <a class="el" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>.</p>

<p>Referenced by <a class="el" href="group__pbuf.html#ga6d803d9945bffb7ad97743f2fa503da6">pbuf_get_at()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
